Great — I’ll prepare everything needed for a complete parking permit web application that includes full MVC functionality, CRUD operations, API integration, and Azure deployment.

I’ll also include documentation with the ERD diagram, GitHub README structure, self-reflections, and a slide deck for your final presentation. I’ll let you know once the full solution is ready for review.

# Parking Permit Management System – Final Project Documentation

## Project Overview

The Parking Permit Management System is a web application designed to streamline the administration of parking permits. It follows a **Model–View–Controller (MVC)** architecture for a clear separation of concerns, improving maintainability ([Model–view–controller - Wikipedia](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#:~:text=Model%E2%80%93view%E2%80%93controller%20,These%20elements%20are)). The application provides full **CRUD** (Create, Read, Update, Delete) functionality for managing users, vehicles, parking permits, and parking lots. All data is stored persistently in a cloud database (Azure SQL), and the app integrates with external APIs (e.g. Google Maps) to enhance functionality. The system is deployed on **Azure App Service**, leveraging a scalable, managed hosting environment ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Azure%20App%20Service%20%20provides,and%20connected%20to%20SQL%20Database)). This document outlines the project’s features, technical design, implementation details, and final deliverables.

## Features and Requirements

The application implements the following key features to meet the project requirements:

- **User Management:** Full CRUD operations for user accounts (e.g. create new users, edit profiles, list users, and delete users). Each user may have associated vehicles and permits.
- **Vehicle Management:** CRUD functionality for vehicles, including linking vehicles to owners (users). Users can register their vehicles with details like license plate, make, model, etc.
- **Permit Management:** CRUD operations for parking permits. Permits link a user’s vehicle to a parking lot with a validity period. Administrators can issue new permits, view permit details, update permit status, or revoke permits.
- **Parking Lot Management:** CRUD for parking lot records. Each parking lot entry stores information such as lot name, location (address or coordinates), and capacity. This data is used to display parking locations on a map and track permit allocations per lot.
- **Mapping Integration:** Integration with the Google Maps API to display parking lot locations visually. For example, the application shows an interactive map with markers for each parking lot, using stored latitude/longitude coordinates ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=In%20this%20article%20I%20will,Net%20MVC%205%20Razor)) ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=Following%20is%20the%20schema%20of,Cities%20and%20their%20Geographical%20Locations)). Users can view lot locations and possibly get directions via Google Maps.
- **Authentication & Authorization:** *(If applicable)* Secure login system so that only authorized users (e.g. admins) can manage data. Regular users might have limited access (e.g. view their own permits).
- **Professional UI/UX:** A clean, responsive user interface with intuitive navigation. Pages are styled professionally using modern CSS frameworks (like Bootstrap) for a consistent look and mobile-friendly design ([GitHub - dotnetdew/Parking-Zone3: Open source ASP.NET MVC project](https://github.com/dotnetdew/Parking-Zone3#:~:text=,Server%20as%20the%20database%20backend)). This includes a polished **About Us** page.
- **About Us Page:** A dedicated page introducing the development team with professional photos, names, and roles. It also provides a link to the project’s GitHub repository or README for transparency. This page adds credibility and personalizes the project.

All features have been tested for full functionality. The app has been manually tested through all CRUD workflows, and any bugs have been fixed to ensure a smooth user experience. Optional enhancements like search filters (e.g. search for a vehicle by license plate) and pagination in lists have been added where appropriate to improve usability.

## Architecture and Tech Stack

**Architecture:** The project is built following the **MVC architecture**, which divides the application into three interconnected components – the Model (data and business logic), the View (UI templates), and the Controller (request handling and coordination) ([Model–view–controller - Wikipedia](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#:~:text=Model%E2%80%93view%E2%80%93controller%20,These%20elements%20are)). This separation ensures that the core data logic is isolated from presentation logic, making the app easier to develop, test, and maintain. Controllers handle incoming HTTP requests, interact with Models (e.g., querying or updating the database), and then pass data to Views which render HTML for the browser. This design pattern was chosen to align with best practices for web application development and to satisfy the requirement of an MVC structure.

**Technologies Used:** The application is implemented using **ASP.NET Core MVC** (C#) as the primary web framework. ASP.NET Core was selected for its robust support of MVC, built-in identity features, and smooth integration with Azure services. The backend follows a layered approach: controllers for request handling, services/managers for business logic (if complexity grows), and entity models representing the data. On the front-end, the app uses **Razor views** (server-rendered HTML) enhanced with **Bootstrap 5** for responsive styling and some **JavaScript/jQuery** for interactive elements (such as form validations or dynamic map loading) ([GitHub - dotnetdew/Parking-Zone3: Open source ASP.NET MVC project](https://github.com/dotnetdew/Parking-Zone3#:~:text=,Server%20as%20the%20database%20backend)). This combination ensures a seamless and responsive user experience for both desktop and mobile users ([GitHub - dotnetdew/Parking-Zone3: Open source ASP.NET MVC project](https://github.com/dotnetdew/Parking-Zone3#:~:text=Parking%20Zone)).

**Data Layer:** For data access, the project uses **Entity Framework (EF) Core** as an Object-Relational Mapper (ORM) to interact with the Azure SQL Database. Using EF Core Code-First approach, the team defined C# model classes for each entity (User, Vehicle, Permit, ParkingLot), and EF automatically generates the database tables and relationships based on these models ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=The%20sample%20project%20contains%20a,using%20Entity%20Framework%20Code%20First)). This simplifies development and maintenance, as the data schema evolves in sync with the application models. The database context (e.g., `ApplicationDbContext`) manages entity sets and is configured with a connection string to the Azure SQL Database ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=The%20app%20uses%20a%20database,to%20an%20Azure%20SQL%20Database)). This connection string is stored securely (in configuration settings) and used by the application to connect to the cloud database at runtime.

**External APIs:** The primary external API integrated is the **Google Maps JavaScript API** for displaying maps. On pages where parking lot information is shown, the app loads a Google Map in an embedded widget. The map is centered based on the parking lot’s coordinates and shows a marker (or multiple markers for a list of lots). Implementing this required obtaining a Google Maps API key and including the Google Maps script in the HTML with that key ([
	Google Map Using Bootstrap In ASP.NET MVC - Part One
](https://www.c-sharpcorner.com/blogs/google-map-using-bootstrap-in-asp-net-mvc-part1#:~:text=Steps)). The application passes the parking lot coordinates from the database to the front-end (for example, via JSON or data attributes), and client-side JavaScript uses the Google Maps API to plot the marker. This integration enhances the user’s ability to visualize where each lot is located in real-world geography ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=In%20this%20article%20I%20will,Net%20MVC%205%20Razor)).

**Cloud Platform:** The app is deployed on **Microsoft Azure**. Azure was chosen because it provides easy integration for both the web application and the database in one ecosystem. The **Azure App Service** hosts the web application as a managed Platform-as-a-Service. This means Azure handles the server infrastructure, scaling, and patching, allowing the team to focus on development. Azure App Service is highly scalable and offers a self-patching web hosting environment ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Azure%20App%20Service%20%20provides,and%20connected%20to%20SQL%20Database)), ensuring reliability and security for the deployed app. The database is hosted on **Azure SQL Database**, a fully-managed cloud relational database service by Microsoft. Using Azure SQL provides high availability, backups, and scalability out-of-the-box. It also means no managing of database servers directly – a benefit since Azure SQL is a **database-as-a-service (DBaaS)** where infrastructure management is handled by Azure ([Modernize to cloud with Azure SQL Database - Microsoft SQL Server Blog](https://www.microsoft.com/en-us/sql-server/blog/2018/04/25/modernize-to-cloud-with-azure-sql-database/#:~:text=One%20way%20IT%20organizations%20can,without%20needing%20to%20manage%20infrastructure)).

## Database Design (ERD)

The persistent storage for the application is an Azure SQL Database. The schema was designed to model the core entities and their relationships for parking permit management. An **Entity-Relationship Diagram (ERD)** was created and refined during development. The main entities include:

- **User:** Represents a person who can own vehicles and permits. Attributes might include UserID (primary key), name, email, password hash, role (e.g. admin or regular user), etc.
- **Vehicle:** Represents a vehicle registered by a user. Attributes include VehicleID (PK), license plate, make, model, color, and a foreign key linking to the owner (UserID). A user can have multiple vehicles (one-to-many relationship from User to Vehicle).
- **ParkingLot:** Represents a parking lot or location where permits are valid. Attributes include LotID (PK), lot name, address, capacity, and perhaps coordinates (latitude, longitude for map integration). This allows storing geolocation for use with Google Maps ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=The%20database%20records%20consisting%20of,Net%20MVC%205%20Razor)).
- **Permit:** Represents a parking permit issued for a specific vehicle (and implicitly to the vehicle’s owner) for a specific parking lot. Key fields include PermitID (PK), an identifier or permit number, VehicleID (FK to Vehicle), LotID (FK to ParkingLot), issue date, expiration date, and permit type (e.g. student, staff, visitor – depending on context).

**Relationships:** Each Permit is associated with one Vehicle and one Parking Lot (assuming permits are lot-specific). Each Vehicle is owned by one User, and a User can have many Vehicles. A User may also have multiple Permits through their vehicles. The ParkingLot entity can have many Permits associated with it (all permits valid for that lot). These relationships ensure referential integrity; for instance, a permit cannot exist without a valid vehicle and lot. The ERD diagram (included in the final submission) illustrates these entities and connections visually, making it easier to understand the data model at a glance.

**Azure SQL Implementation:** The team used EF Core migrations to translate the model changes into database schema updates. Upon first deployment, the database was created in Azure with the necessary tables. Using Azure SQL ensured the data is stored in a **fully managed, scalable SQL database service** ([Modernize to cloud with Azure SQL Database - Microsoft SQL Server Blog](https://www.microsoft.com/en-us/sql-server/blog/2018/04/25/modernize-to-cloud-with-azure-sql-database/#:~:text=One%20way%20IT%20organizations%20can,without%20needing%20to%20manage%20infrastructure)). This provides benefits like built-in security, automated backups, and performance tuning, which are essential for a production-ready application without the overhead of managing a SQL Server manually. Connection to the database is done via a secure connection string, and sensitive information (like credentials) is stored in Azure’s configuration settings rather than hard-coded.

## External API Integration (Google Maps)

One of the project requirements was to integrate a relevant external API to enrich the application’s functionality. We chose **Google Maps API** to display parking lot locations on an interactive map. This integration adds visual context for users, allowing them to see where parking lots are located and perhaps get directions.

**Google Maps JavaScript API:** We integrated the Google Maps **JavaScript API v3** into the Parking Lot views. To do this, the team registered for a Google Cloud API key (restricting its usage to our site’s domain for security). Including Google’s script with our API key enables the maps functionality ([
	Google Map Using Bootstrap In ASP.NET MVC - Part One
](https://www.c-sharpcorner.com/blogs/google-map-using-bootstrap-in-asp-net-mvc-part1#:~:text=Steps)). On the Parking Lot details page, for example, we display a map centered at that lot’s latitude/longitude. If the lot coordinates are stored in the database (as `Latitude` and `Longitude` fields), they are passed to the view. A small JavaScript snippet runs on page load to initialize a map object, center it to the given coordinates, and place a pin (marker) at the location.

**Multiple Markers:** On a page that lists all parking lots, we optionally show a map with **multiple markers** – one for each lot. This demonstrates using Google Maps with data from our database. We construct a JavaScript array of coordinates and names from the ParkingLot records and use the Google Maps API to iterate and add markers for each, possibly with info windows showing the lot name. This approach is documented in similar examples of integrating Google Maps with database data ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=In%20this%20article%20I%20will,Net%20MVC%205%20Razor)) ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=Following%20is%20the%20schema%20of,Cities%20and%20their%20Geographical%20Locations)), and it allows for a dynamic map experience.

**Benefits:** The map integration makes the application more user-friendly by providing a geographical context. For a campus or city scenario, users can quickly identify which permit corresponds to which parking area on the map. It also adds a modern, interactive element to the UI. The use of Google’s API, while requiring careful handling of the API keys and usage limits, proved to be a relevant enhancement aligning with the project’s requirement for an external API integration.

## Deployment on Azure App Service

The web application has been deployed to **Azure App Service**, fulfilling the requirement to host the project in the cloud. Azure App Service was used as it is a managed platform that supports ASP.NET Core applications natively. Key details of the deployment:

- The team created an **Azure App Service** instance (Windows stack for .NET) and an **Azure SQL Database** through the Azure Portal. These resources were placed in a single Resource Group for easy management.
- Publishing the app was done using Visual Studio’s publishing wizard: we selected Azure as the target, chose Azure App Service, and then either created a new App Service instance or selected an existing one ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Publish%20ASP)). Visual Studio handled packaging the application and deploying it to the Azure cloud.
- The database connection string on Azure was configured in the App Service’s Application Settings. Azure provides a secure way to store the connection string (named `MyDbConnection` in our app, for example) so that the deployed app can reach the Azure SQL DB. Because the connection string name in Azure matches what the app expects (from appsettings or Web.config), the Entity Framework context seamlessly connects to the cloud database after deployment ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=The%20app%20uses%20a%20database,to%20an%20Azure%20SQL%20Database)).
- After deployment, the application is accessible at a URL like `https://<app_name>.azurewebsites.net`. For this project, a custom name was chosen (e.g., `parkingpermit-app.azurewebsites.net`). This URL was shared with testers and the instructor as the **Deployed Application URL** in the final deliverables.
- Azure App Service provides a robust environment – it auto-scales and manages the underlying servers, which means our team did not need to maintain an IIS server or virtual machine. The platform is *self-patching and highly scalable*, as noted in Microsoft’s documentation ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Azure%20App%20Service%20%20provides,and%20connected%20to%20SQL%20Database)). This ensured that even if usage spikes (many users accessing permit info), Azure can scale out to handle the load. It also applied security patches to the OS and framework, reducing maintenance overhead.

To verify a successful deployment, we performed final testing on the live site. All features (CRUD operations, map display, login, etc.) were re-tested on Azure. We also utilized Azure’s logging and monitoring (via the App Service logs and Application Insights) to ensure there were no runtime errors or performance issues in the cloud environment. The deployed app remained live and accessible for demonstration during the project presentation.

## User Interface and User Experience

Creating a professional and user-friendly interface was a priority. We applied modern web design practices so that the application is both visually appealing and easy to navigate:

- **Responsive Design:** The use of **Bootstrap** CSS framework ensured that pages are mobile-friendly and scale well on different screen sizes. We utilized Bootstrap’s grid system for layout and its components (navigation bar, forms, buttons, tables) for consistent styling. The result is a clean interface that looks like a contemporary web app rather than a plain school project, aligning with professional standards ([GitHub - dotnetdew/Parking-Zone3: Open source ASP.NET MVC project](https://github.com/dotnetdew/Parking-Zone3#:~:text=,Server%20as%20the%20database%20backend)).
- **Navigation:** A fixed navigation bar is present on all pages with links to key sections: Users, Vehicles, Permits, Parking Lots, and the About Us page. If using authentication, the nav bar also shows login/logout or the current user’s name when logged in.
- **Forms and Validation:** All create/edit forms for the entities include clear labels and placeholders. We added client-side validation using either HTML5 validation attributes or JavaScript, as well as server-side validation to handle invalid input gracefully. For example, required fields will prompt the user if left empty, and fields like email or dates are validated for correct format.
- **Tables and Views:** Listing pages (e.g., list of users, list of permits) are presented in tables with proper headers. Action links or buttons (Edit, Details, Delete) are clearly visible for each row, following a typical CRUD interface pattern ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Image%3A%20New%20ASP,box)). We used conditional formatting to, for instance, highlight expired permits in red or show active/inactive status clearly.
- **Feedback and Alerts:** The UI provides feedback for user actions. After creating or updating a record, a success message is shown (using a Bootstrap alert component). Similarly, deletion asks for confirmation to prevent accidental removals.
- **About Us Page:** The About Us page introduces the development team. Each team member is displayed with a professional photo (e.g., a headshot), name, and role on the project (e.g., “Frontend Developer”, “Database Specialist”, etc.). Beneath each member’s info, we included a brief one-line statement or a fun fact to humanize the team. This page also includes a link or button to the project’s GitHub repository and README, allowing users or evaluators to find the source code and additional documentation. The styling of this page is kept consistent with the rest of the site, but with a more personal touch – for example, using a card layout for each member’s profile.

The overall UX has been tested with potential users for clarity. Adjustments were made based on feedback; for instance, adding a search bar on the permits page to quickly find a permit by ID or vehicle plate, and ensuring the Google Map on the parking lot page is appropriately sized and doesn’t overwhelm the page on small screens.

## Testing and Quality Assurance

Before final deployment and submission, the team rigorously tested all aspects of the application:

- **Functional Testing:** Each CRUD operation was tested. We created sample users, vehicles, permits, and lots to ensure that create operations add records to the database, edit operations correctly update them, and delete operations remove them. The interdependencies were also tested (e.g., ensuring you cannot create a permit for a non-existent vehicle, or what happens if a vehicle is deleted – ideally, cascading deletes or restrictions are handled appropriately in the database).
- **Integration Testing:** We tested the integration points like the database and the Google Maps API. This included deliberately breaking the database connection (to ensure the app fails gracefully with an error message) and using invalid API keys for Google Maps (to see that we handle map load errors). After confirming error handling, we restored the correct configurations.
- **Cross-Browser Testing:** The UI was opened in modern browsers (Chrome, Firefox, Edge, Safari) to verify consistent behavior and styling. Minor CSS tweaks were made to address any inconsistencies.
- **Responsive Testing:** Using browser dev tools and actual devices, we checked that the layout adjusts for various screen sizes (mobile, tablet, desktop). The menu collapses into a mobile-friendly toggle on small screens as expected, and forms and tables scroll or stack properly.
- **User Acceptance Testing:** We had a few peers act as users to run through common tasks: e.g., “register a new vehicle and then issue a permit for it”. Their feedback led us to refine some instructions and labels to be more intuitive.
- **Performance Testing:** Although a small project, we tested with a larger dataset (e.g., 100+ permits) to ensure the pages still load quickly and that the Azure SQL queries are optimized (we added necessary indexes for faster lookups on foreign keys like VehicleID, etc., once data volume grew).

By the end of testing, we confirmed that the application meets all requirements and is stable. We documented any known limitations or minor bugs (none critical) in the README so they are transparent.

## Presentation Slide Deck

As part of the final deliverables, we prepared a **6-minute presentation slide deck** to showcase the project. The slide deck is structured as follows:

1. **Title Slide:** Includes the project title “Parking Permit Management System”, the course or context (e.g., “Final Project”), and team member names. This slide also provides a very brief project overview or tagline, for instance: “A web application for managing parking permits, built with ASP.NET Core MVC and Azure”.
2. **About Us Slide:** Features the team members with names, photos, and roles, similar to the About Us page on the site. This establishes the team composition right at the beginning of the presentation.
3. **Technical Overview & Architecture:** A slide (or two) that visually presents the system architecture. This includes an architecture diagram showing how the MVC components interact, how Azure SQL and Azure App Service are connected ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Azure%20App%20Service%20%20provides,and%20connected%20to%20SQL%20Database)), and how the external API (Google Maps) fits in. We bullet the tech stack: ASP.NET Core MVC, Azure SQL, Entity Framework, Azure App Service, Google Maps API, Bootstrap, etc. We also mention any noteworthy design decisions or challenges (for example, deciding on the data schema or handling security).
4. **Demo (Screenshots & Live Link):** Since the presentation is short, we prepared a few screenshots highlighting core features: the Users listing page, a Permit detail page with map, and the About Us page. Each screenshot is accompanied by a brief explanation. If internet connectivity allows, we also have a live demo by navigating the actual deployed site in a browser. The slide includes the app URL so viewers can try it later.
5. **Learnings & Challenges:** We dedicate a slide to what the team learned and the challenges we faced. This includes technical learnings (e.g., “Deploying to cloud and managing a cloud database”, “Integrating a mapping API into a web app”) and teamwork learnings (e.g., coordinating via Git, merging code). Challenges mentioned might include debugging deployment issues (like firewall settings for Azure SQL), learning the Google Maps API, or ensuring data consistency with multiple related entities. We briefly note how we overcame these challenges.
6. **Extensions & Future Work:** The final content slide talks about potential extensions to the project. For instance, features that could be added if we had more time: a reporting dashboard to see usage statistics, email notifications when a permit is about to expire, support for uploading documents (like proof of registration), or a QR code for each permit for enforcement scanning. We also mention any planned improvements (e.g., more rigorous security hardening) if this were to continue beyond the class. This shows that we’re thinking ahead and know how to expand the project.
7. **Thank You & Q&A:** The closing slide thanks the audience/professor and prompts for questions.

The slide deck is visually consistent with the application’s theme (we used similar color schemes and our team logo if we had one). We kept text minimal on slides in favor of speaking points, given the 6-minute limit. The slides will be submitted as part of the final materials (in PDF or PPTX format) for reference.

## Final Deliverables and Documentation

Along with the working web application and presentation, the project deliverables include comprehensive documentation and supporting materials:

- **Deployed Application URL:** The live Azure URL where the app is running (e.g., `https://parkingpermit-app.azurewebsites.net`). This allows instructors to verify functionality online.
- **Source Code Repository:** A link to the GitHub repository containing all source code. The README in the repo provides an overview, setup instructions, and any relevant notes (this README link is also provided on the About Us page for convenience).
- **Updated ERD Diagram:** The final version of the Entity-Relationship Diagram reflecting the implemented database schema. This diagram is included in the documentation (as an image or PDF) and illustrates tables (entities), keys, and relationships (crow’s foot notation for cardinality). It matches the description given in the Database Design section of this document.
- **Git Log Output (Contributions):** To evidence individual contributions, we include an excerpt from the project’s Git history. We ran `git log` or a similar command to show commits from all team members. The log (or a summarized version like `git shortlog`) is provided, indicating which team members authored which commits. This demonstrates collaborative development and version control practice. Each member’s commit messages reflect their work (e.g., “Implemented Vehicle CRUD”, “Added Google Maps integration on lot page”, “Styled About Us page”, etc.).
- **Team Members’ Self-Reflections:** Each team member has written a short reflection (a few paragraphs) on their personal learning experience during the project. These reflections cover what they contributed, challenges they overcame, skills they improved, and how the project experience will benefit them in the future. The reflections are included in the documentation to provide insight into the team’s growth and to satisfy the course’s reflection requirement.
- **Slide Deck File:** A copy of the final presentation slide deck used during the project presentation (in PowerPoint or PDF format) is submitted. This ensures the instructor can review the slides in detail. The slides complement this written documentation by highlighting key points in a visual manner, but this document contains more exhaustive details.

All documentation is well-organized and clearly formatted. We have included a table of contents and section headings (as seen above) for easy navigation. Source code links are provided where appropriate – for example, if referencing a particular function or module in this write-up, we would link to the relevant file in GitHub. Throughout the documentation, we maintained a professional tone and clarity, making it suitable as a stand-alone description of the project for any technical evaluator.

## Conclusion

In conclusion, the Parking Permit Management System project was successfully implemented with all required features. By adhering to the MVC architecture and using Azure’s cloud services, the team built a scalable and maintainable web application. Integrating Google Maps added practical value, and deploying to Azure demonstrated real-world readiness of the app. We faced and overcame several challenges, from database schema design to API integration and deployment configurations, which provided invaluable hands-on experience. The end result is a fully functional, polished application that meets the needs of managing parking permits efficiently.

Moving forward, the project could be extended with additional features such as real-time occupancy tracking of parking lots, an admin dashboard with analytics, or support for mobile platforms (e.g., a companion mobile app or PWA). These extensions, as outlined in the documentation and presentation, could further enhance the system’s utility. Nonetheless, the core goals for this final project have been achieved. We delivered a tested, deployed solution along with thorough documentation and a team presentation, reflecting the culmination of our learning in this course.

**Sources:** The development process was guided by various resources. Microsoft’s documentation on deploying ASP.NET apps to Azure with SQL Database was particularly helpful ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=Azure%20App%20Service%20%20provides,and%20connected%20to%20SQL%20Database)) ([Tutorial: ASP.NET app with Azure SQL Database - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/app-service-web-tutorial-dotnet-sqldatabase#:~:text=The%20sample%20project%20contains%20a,using%20Entity%20Framework%20Code%20First)). The team referred to official docs and community examples for integrating Google Maps in an MVC app ([
	Google Map Using Bootstrap In ASP.NET MVC - Part One
](https://www.c-sharpcorner.com/blogs/google-map-using-bootstrap-in-asp-net-mvc-part1#:~:text=Steps)) ([
        Integrate Google Maps in ASPNet MVC](https://www.aspsnippets.com/Articles/1794/Integrate-Google-Maps-in-ASPNet-MVC/#:~:text=In%20this%20article%20I%20will,Net%20MVC%205%20Razor)). We also followed best practices for MVC design as outlined in software architecture references ([Model–view–controller - Wikipedia](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#:~:text=Model%E2%80%93view%E2%80%93controller%20,These%20elements%20are)). All these sources (and others referenced in the text) ensured that we built the application using current, recommended techniques and solved problems using proven approaches. The inclusion of citations in this document credits these resources and provides readers with pointers for further reading on specific topics.